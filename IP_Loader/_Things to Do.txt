THINGS TO DO
------------

* Enhance to Identify
  * Set up proper Broadcast addresses
  * Use TIdStack.IsIP to check for valid IP address

* Handle errors
  * TCP connection
  * Propeller Protocol
  * Prompts
  * Dropped UDP Packets
    * Retransmit a limited number of times

* Command
  * Add check for DL (Destination IP) and set it to be host's IP.

* Download Method
  * Loader Image
    * Host sets target bit period value in loader image (before download) according to default/user-specified crystal speed
      * May need to be last values in image for implementation simplicity
      * May need to set clock speed value LONG[0] and clock mode WORD[?]
    * Should support initial and target 9,600/19,200/38,400/57,600/115,200/230,400/460,800/921,600/1,000,000/1,500,000/2,000,000/3,000,000 baud rates
    * Handshake:
      * Once loader starts, it transmits an acknowledgement to the host
      * Host receives acknowledgement and switches to target baud rate
      * Host begins final image transmission
    * Final Image Transmission:
      * Data is in units of 32-bits (longs)
      * Packetized; image data is encased in a packet wrapper
        * Packet wrapper leads each packet with a 32-bit Packet Size and a 32-bit Packet ID
          * Packet ID has dual purpose
            * it uniquely identifies the packet; every unique packet in the stream has a unique ID (duplicate packets have the same ID)
            * it indicates how many total packets are in (or left) in the Propeller Application Image
              * Packet ID count's down to 1.  The host precalculates the total number of required packets as the value for the first packet's Packet ID.
                Further packets use the previous Packet ID - 1.
        * Packet wrapper "may" end with a 32-bit CRC32 (if UDP doesn't dump corrupted packets)
      * Each loader-received packet is acknowledged (positively or negatively)
        * Host retransmits packets that are not acknowledged, or negatively acknowledged
        * Loader positively acknowledges duplicates, but dumps duplicate data
        * Loader "may" negatively acknowlege packet and request previous packet (if UDP does't dump corrupted packets; ie: a corrupted acknowledge from before)
          * Host retransmits requested packet if necessary
      * Loader acknowledges Application Image (positively or negatively); this is a RAM Checksum response
      * Loader acknowledges EEPROM write
    

* Consider
  * Adding Soft AP mode negotiation
  * Adding Wi-Fi Protected Setup mode (to hardware?)
  * Determine how to find local addresses and subnet masks
  * Recording and restoring previous settings when done
    * This may be simpler with a single command, if there is one.
  * Could use I/O pin to instantiate flow control for a certain amount of time during reset,
    this way we can time serial output's start in relation to reset better.
  * Could stick to UDP for data because it's less overhead and timing in relation to reset is easer.

  * Why are we not able to set the IP or AP parameters?  There's no response, and then the XBee seems to lock up.

  * Figure out how to deal with late packet arrival.  Sometimes during Identify, the packets arrive later than the timeout.  Also, during programming, the UDP
    response is not seen right away.


THINGS DONE
-----------

* Enhance to request acknowledgements
* Enhance to randomize header ID
* Enhance to Identify
  * Broadcast message
  * Retrieve and display Node Name
  * Retrieve and display IP Address
  * Retrieve and display port number
  * Retrieve and display MAC address
  * Create Pseudo-Communication port number
  * Accept multiple responses
* Support Configuration Checksum
* Changed TargetIPx to RemoteIPx
* Heavily revised to include a Serial TCP, Serial UDP, and Application UDP client and methods for that purpose.
* All UDP methods use the Application UDP Client except the SendUDP (when told not to) and the ReceiveUDP methods.
* Appliation UDP Client is bound to $BEE.
* Calculate round-trip time

First Try:
  * Dropped UDP Packets
    * Retransmit a limited number of times

* Download Method
  * Switch to compressed calibration pulse + handshake + download command + image size + loader image (single packet)
  * Loader Image
    * Full Propeller Application Written in Propeller Assembly
    * Handshake:
      * Uses standard bit encoding (instead of Propeller bit encoding)

* Timing
  * Try making routine to sleep.
    * Use Sleep(time), but check time before and afterwards.  If delta_time is not close to time, Sleep again for time-delta_time.

* Add TCP
  * To connect

* Find and maintain desired response packet in RxBuf (last) before exiting Get/SetXBee method.

* Add AT commands
  * to set low pulse time
  * to set RESn state
  * to get MAC Address
  * to set baud rate
  * to set parity
  * to set stop bits
  * to get maximum RF payload
    * This feature is static, it does not change according to the number of bytes in the XBee's UART
  * to get IP Mask
  * to get IP Gateway

* Simplify CmdStream

* Handle errors
  * Invalid IP Address (255.255.255.255)
  * No acknowledgement

* Handle
  * String issues in ParameterValue
  * Zero-termination of Parameter (when receiving)


THINGS TO PONDER
----------------

* Use the form "XB####" in place of a "COM#" to select the desired wireless port to download to.  The #### is based on the last digits of the XBee's MAC address.
* For boards that include a USB and an XBee socket, replace the USB circuit with one that behaves like an XBee USB Adapter (when and XBee is attached) and like
  a normal USB connection when not.
  * This may still have to be a switched mechanism
    * Can use a 2-position switch to flip between USB and XBee downloading
    * The switch will activate a simple transistor circuit to mux USB and XBee to Rx, Tx, and RESn.
      * SN54LV4053A, SN74LV4053A (296-3833-1-ND) Triple 2:1 16TSSOP $0.49 qty 1, $0.31 qty 100, $0.18 qty 1000
* Update TCP
  * To allow transmiting similar to UDP
