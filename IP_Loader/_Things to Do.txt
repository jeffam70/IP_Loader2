THINGS TO DO
------------

* Enhance to Identify
  * Set up proper Broadcast addresses
  * Use TIdStack.IsIP to check for valid IP address

* Handle errors
  * TCP connection
  * Propeller Protocol
  * Prompts
  * Dropped UDP Packets
    * Retransmit a limited number of times

* Command
  * Add check for DL (Destination IP) and set it to be host's IP.

* Download Method
  * Switch to compressed calibration pulse + handshake + download command + image size + loader image (single packet)
  * Loader Image
    * Full Propeller Application Written in Propeller Assembly
    * Host sets initial bit period value and target bit period value in loader image (before download) according to default/user-specified crystal speed
      * May need to be last values in image for implementation simplicity
    * Should support initial and target 9,600/19,200/38,400/57,600/115,200/230,400/460,800/921,600/1,000,000/1,500,000/2,000,000/3,000,000 baud rates
    * Handshake:
      * Uses standard bit encoding (instead of Propeller bit encoding)
      * Once loader starts, it acknowledges host
      * Host receives acknowledgement and switches to target baud rate
      * Host begins final image transmission
    * Final Image Transmission:
      * Packetized; image data is encased in a packet wrapper
        * Packet wrapper leads each packet with a 16-bit Packet ID and a 16-bit Packet Length
        * Packet wrapper "may" end with a 32-bit CRC32 (if UDP doesn't dump corrupted packets)
      * First packet's payload leads with an 8-bit download command (Program RAM or EEPROM) and a 24-bit application image size
      * Each loader-received packet is acknowledged (positively or negatively)
        * Host retransmits packets that are not acknowledged, or negatively acknowledged
        * Loader positively acknowledges duplicates, but dumps duplicate data
        * Loader "may" negatively acknowlege packet and request previous packet (if UDP doens't dump corrupted packets; ie: a corrupted acknowledge from before)
          * Host retransmits requested packet if necessary
      * Loader acknowledges Application Image (positively or negatively); this is a RAM Checksum response
      * Loader acknowledges EEPROM write
    

* Consider
  * Adding Soft AP mode negotiation
  * Adding Wi-Fi Protected Setup mode (to hardware?)
  * Determine how to find local addresses and subnet masks
  * Recording and restoring previous settings when done
    * This may be simpler with a single command, if there is one.
  * Could use I/O pin to instantiate flow control for a certain amount of time during reset,
    this way we can time serial output's start in relation to reset better.
  * Could stick to UDP for data because it's less overhead and timing in relation to reset is easer.

  * Why are we not able to set the IP or AP parameters?  There's no response, and then the XBee seems to lock up.

  * Figure out how to deal with late packet arrival.  Sometimes during Identify, the packets arrive later than the timeout.  Also, during programming, the UDP
    response is not seen right away.


THINGS DONE
-----------

* Enhance to request acknowledgements
* Enhance to randomize header ID
* Enhance to Identify
  * Broadcast message
  * Retrieve and display Node Name
  * Retrieve and display IP Address
  * Retrieve and display port number
  * Retrieve and display MAC address
  * Create Pseudo-Communication port number
  * Accept multiple responses
* Support Configuration Checksum
* Changed TargetIPx to RemoteIPx
* Heavily revised to include a Serial TCP, Serial UDP, and Application UDP client and methods for that purpose.
* All UDP methods use the Application UDP Client except the SendUDP (when told not to) and the ReceiveUDP methods.
* Appliation UDP Client is bound to $BEE.
* Calculate round-trip time

First Try:
  * Dropped UDP Packets
    * Retransmit a limited number of times

* Timing
  * Try making routine to sleep.
    * Use Sleep(time), but check time before and afterwards.  If delta_time is not close to time, Sleep again for time-delta_time.

* Add TCP
  * To connect

* Find and maintain desired response packet in RxBuf (last) before exiting Get/SetXBee method.

* Add AT commands
  * to set low pulse time
  * to set RESn state
  * to get MAC Address
  * to set baud rate
  * to set parity
  * to set stop bits
  * to get maximum RF payload
    * This feature is static, it does not change according to the number of bytes in the XBee's UART
  * to get IP Mask
  * to get IP Gateway

* Simplify CmdStream

* Handle errors
  * Invalid IP Address (255.255.255.255)
  * No acknowledgement

* Handle
  * String issues in ParameterValue
  * Zero-termination of Parameter (when receiving)


THINGS TO PONDER
----------------

* Use the form "XB####" in place of a "COM#" to select the desired wireless port to download to.  The #### is based on the last digits of the XBee's MAC address.
* For boards that include a USB and an XBee socket, replace the USB circuit with one that behaves like an XBee USB Adapter (when and XBee is attached) and like
  a normal USB connection when not.
  * This may still have to be a switched mechanism
    * Can use a 2-position switch to flip between USB and XBee downloading
    * The switch will activate a simple transistor circuit to mux USB and XBee to Rx, Tx, and RESn.
      * SN54LV4053A, SN74LV4053A (296-3833-1-ND) Triple 2:1 16TSSOP $0.49 qty 1, $0.31 qty 100, $0.18 qty 1000
* Update TCP
  * To allow transmiting similar to UDP
